### 剑指 Offer 56 - I. 数组中数字出现的次数

一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 O(n)，空间复杂度是 O(1)。

输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]

输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]

限制：
2 <= nums.length <= 10000

本题目难点出现在，空间复杂度要求是 O(1)

分析：

1. 如果不考虑空间复杂度，可以考虑使用一个哈希表，记录每个数据出现的次数，最终筛选出次数为 1，的值即可
2. 而且除了需要寻找的数字，其余的数字都出现了且只出现了两次 ———— 这就是某个数据的状态
3. 涉及到状态的，可以考虑使用 bitmap 或者有限状态机

当遍历完一个数字的状态：

- 初始状态
- 出现 1 次
- 出现 2 次

一共有三种状态， 一个 bit 位最多只能表示两种状态，所以需要两个 bit 位置来表示一个数字的位置
00： 表示初始状态
01： 表示出现了 1 次
10： 表示出现了 2 次

位运算：

- 相同的数异或等于 0
- 不同的数异或等于 1
- 0 和非零数异或等于它本身
  若 a&0001=1 ，则 aa 的第一位为 1；
  若 a&0010=1 ，则 aa 的第二位为 1 ；

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
所以数组里所有的数字都进行异或，得到的结果就是这两个剩余数字的异或结果
假设异或的结果为 10010：那么说明这两个数从右向左数第 2 位是不同的
那么可以根据数组里面所有数的第二位为 0 或者 1 将数组划分为 2 个。
这样做可以将目标数必然分散在不同的数组中，而且相同的数必然落在同一个数组中。
这两个数组里面的数各自进行异或，得到的结果就是答案

```python

class Solution(object):
    def singleNumbers(self, nums):
        ret, index = 0, 0
        for n in nums:
            ret ^= n
        # ret 是所有数字异或的结果
        # 分组，从右边往左（低位往高位）数，第几位是不同的
        # 这一步其实可以根据n & (-n)的快捷方式获得，不过对位运算掌握不是那么熟练的话，记结论容易忘，不如理解实质
        while ret & 1 == 0:
            index += 1
            ret >>= 1
        r1,r2 = 0, 0
        for n in nums:
            # 不能使用异或进行分组，无法化解高位的1
            if (n >> index) & 1 == 0: # 第二位为1 的数字放一组，然后全部进行异或，相同的数字会抵消掉
                r1 ^= n
            else:  # 第二位为0 的数字放一组，然后全部进行异或，相同的数字会抵消掉
                r2 ^= n
        return [r1, r2]

```

```python
class Solution:
    def singleNumbers(self, nums: List[int]) -> List[int]:
        x, y, n, m = 0, 0, 0, 1
        for num in nums:         # 1. 遍历异或
            n ^= num
        while n & m == 0:        # 2. 循环左移，计算 m
            m <<= 1
        for num in nums:         # 3. 遍历 nums 分组
            if num & m: x ^= num # 4. 当 num & m != 0
            else: y ^= num       # 4. 当 num & m == 0
        return x, y              # 5. 返回出现一次的数字


```
